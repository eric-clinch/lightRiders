# LightRiders AI

An AI used to compete in the Riddles.io Lightriders competition. At the time of writing, this bot uses the Simultaneous Move Alpha Beta search algorithm to decide what move to make at each turn. More information on this variation of the search algorithm and the other strategies used by this bot can be read below.

## The search algorithm

This AI uses the Simultaneous Move Alpha Beta search algorithm (implemented in the GetMovesSMAB class) to decide what move to make at each turn. This algorithm is similar to the backward induction algorithm (which is also implemented in the GetMovesNash class), but uses strategies similar to the Alpha Beta search algorithm to soundly prune the search tree. This search algorithm relies on the Simplex algorithm to solve linear programming problems, which is necessary both for finding the Nash Equilibtium strategy of a game state and for performing the early pruning of the search tree.

## The evaluation function

All search algorithms implemented in this project use an evaluator in order to estimate how good a given game state would be for us. This evaluator takes a game state (the state of the board) as input, and returns an integer representing how good the game state is for us. Large integer values represent winning game states, while small values represent losing game states.

This AI's evaluation function is implemented in the ChamberEvaluator class. This evaluation function favors game states where the player "controls" more available squares. The player "controls" a square if it can arrive at the square before the opponent can. This evaluation function accounts for "chambers" in the board. Often, choke points exist in the board such that if you pass through the choke point, you cannot return to the "chamber" you came from, and are now stuck in the "chamber" you entered. This evaluation function accounts for the mutual exclusion of chambers. For example, if the player is in chamber A and connected to chambers B and C, then the player cannot necessarily control the squares in both chambers B and C, as it cannot return to chamber A after entering chamber B or C. Using this logic, the equation for counting the number of squares that the player controls after accounting for chamber exclusions looks like this: chamberCount(A) = count(A) + max(chamberCount(B) + chamberCount(C)), where count(x) is the number of controlled squares inside of x. Thus, the chamberCount of a chamber x is determined by counting the number of controlled squares in the chamber plus the maximum of recursively calling chamberCount on each chamber x is connected to. Note that B and C are not connected to A, as entering B or C from A would block the choke point, making them no longer connected. This assumption means that we can view these chambers as a DAG, which is a nice property as it means that our recursive algorithm will always terminate. This isn't always necessarily a correct assumption, however, as it is possible that B and C are connected, so you could travel from A to B to C and back to A, forming a cycle. This configuration, however, is extremely rare in competitive matches, and so it is ignored for now in order to make the algorithm significantly less complicated. Adding the ability to account for this scenario could benefit the AI, and is a potential feature to be added in the future.

## Other implemented search algorithms

While developing this bot, I implemented a few other search algorithms while trying to find the best one for this competition. These search algorithms can be found in classes starting with "GetMoves". Almost all search algorithms are variations of the well known Alpha Beta search algorithm. The majority of these search algorithms use a move sorting heuristic to try to maximize tree pruning. Search algorithms with "CacheTree" or "CT" in their name cache some results from search tree in order to minimize recomputation in the next round's search. The Cache Tree strategy also orders the branches of the cached tree as to maximize pruning.